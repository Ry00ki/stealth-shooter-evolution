<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Stealth Shooter Evolution</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #050912;
      color: #e2e8f0;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .layout {
      width: min(1100px, 94vw);
      display: grid;
      gap: 18px;
      padding: 24px;
      background: #080f1c;
      border-radius: 18px;
      border: 1px solid #1f2937;
      box-shadow: 0 14px 48px rgba(0, 0, 0, 0.45);
    }

    h1 {
      margin: 0;
      font-size: 1.7rem;
      letter-spacing: 0.04em;
    }

    .intro {
      line-height: 1.45;
      font-size: 0.95rem;
      background: #0c1426;
      border-radius: 12px;
      padding: 16px 18px;
      border: 1px solid #253248;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .pill {
      flex: 1 1 140px;
      background: #101c33;
      border: 1px solid #27354d;
      border-radius: 12px;
      padding: 12px 14px;
      display: grid;
      gap: 4px;
      min-width: 140px;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.4);
    }

    .pill .label {
      font-size: 0.65rem;
      letter-spacing: 0.12em;
      color: #94a3b8;
    }

    .pill .value {
      font-size: 1.2rem;
      font-weight: 600;
    }

    canvas {
      background: #030711;
      border-radius: 16px;
      border: 1px solid #111827;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
      width: 100%;
      height: auto;
      image-rendering: pixelated;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button {
      cursor: pointer;
      background: #132542;
      border: 1px solid #294263;
      color: inherit;
      font: inherit;
      border-radius: 9px;
      padding: 9px 14px;
      transition: transform 0.16s ease, background 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      background: #1b3557;
    }

    dialog::backdrop {
      background: rgba(3, 7, 18, 0.75);
    }

    dialog {
      background: #0c1528;
      color: inherit;
      border: 1px solid #24344f;
      border-radius: 14px;
      padding: 24px;
      min-width: min(420px, 90vw);
      box-shadow: 0 24px 64px rgba(0, 0, 0, 0.55);
      text-align: center;
    }

    dialog h2 {
      margin-top: 0;
      font-size: 1.35rem;
    }

    dialog button {
      margin-top: 16px;
    }
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <h1>Stealth Shooter Evolution</h1>
    </header>

    <section class="intro">
      <p><strong>Goal:</strong> Collect intel chips and bank them in the safe zone while avoiding enemy patrols.</p>
      <p><strong>Scalable Design:</strong> Enemies and bonuses are now data-driven. Create new behaviours or pickups by registering new typesâ€”no rewiring required.</p>
    </section>

    <section class="hud">
      <div class="pill"><span class="label">LEVEL</span><span class="value" id="hudLevel">1</span></div>
      <div class="pill"><span class="label">LIVES</span><span class="value" id="hudLives">3</span></div>
      <div class="pill"><span class="label">TIME</span><span class="value" id="hudTime">00:00</span></div>
      <div class="pill"><span class="label">CHIPS</span><span class="value" id="hudChips">0/0</span></div>
      <div class="pill"><span class="label">BONUS</span><span class="value" id="hudBonus">None</span></div>
    </section>

    <canvas id="gameCanvas" width="960" height="600"></canvas>

    <section class="controls">
      <button id="toggleDebug">Toggle Debug (D)</button>
      <button id="restartLevel">Restart Level (R)</button>
      <button id="restartGame">Restart Game (G)</button>
    </section>
  </div>

  <dialog id="modal">
    <h2 id="modalTitle">Paused</h2>
    <p id="modalBody">Take a break, agent.</p>
    <button id="modalClose">Continue</button>
  </dialog>

  <script type="module">
    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    const lerp = (a, b, t) => a + (b - a) * clamp(t, 0, 1);

    class Vector2 {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }

      copy() {
        return new Vector2(this.x, this.y);
      }

      add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      }

      subtract(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }

      scale(s) {
        this.x *= s;
        this.y *= s;
        return this;
      }

      length() {
        return Math.hypot(this.x, this.y);
      }

      normalize() {
        const len = this.length();
        if (len > 0.0001) {
          this.x /= len;
          this.y /= len;
        }
        return this;
      }

      static from(obj) {
        return new Vector2(obj.x, obj.y);
      }
    }

    class Entity {
      constructor(position, radius = 16, options = {}) {
        this.position = Vector2.from(position);
        this.radius = radius;
        this.options = { ...options };
        this.dead = false;
      }

      update() {}
      draw(ctx) {}
    }

    class Player extends Entity {
      constructor(position) {
        super(position, 16, { speed: 180 });
        this.velocity = new Vector2();
        this.carrying = 0;
        this.stamina = 100;
        this.staminaMax = 100;
        this.staminaDrain = 55;
        this.staminaRegen = 45;
        this.superBoost = null;
      }

      applyBonus(bonus) {
        if (bonus.effects.stamina) {
          const { maxMult = 1, regenMult = 1, drainMult = 1, duration = 10 } = bonus.effects.stamina;
          this.staminaMax *= maxMult;
          this.staminaRegen *= regenMult;
          this.staminaDrain *= drainMult;
          this.superBoost = { duration, time: duration, bonus };
        }
      }

      update(dt, input, world) {
        const move = new Vector2();
        if (input.up) move.y -= 1;
        if (input.down) move.y += 1;
        if (input.left) move.x -= 1;
        if (input.right) move.x += 1;
        move.normalize();

        const speed = this.options.speed * (this.superBoost ? 1.35 : 1);
        this.velocity = move.scale(speed);
        this.position.add(this.velocity.copy().scale(dt));

        this.position.x = clamp(this.position.x, this.radius, world.width - this.radius);
        this.position.y = clamp(this.position.y, this.radius, world.height - this.radius);

        if (this.superBoost) {
          this.superBoost.time -= dt;
          if (this.superBoost.time <= 0) {
            this.resetStamina();
          }
        }
      }

      resetStamina() {
        this.staminaMax = 100;
        this.staminaRegen = 45;
        this.staminaDrain = 55;
        this.superBoost = null;
      }

      draw(ctx) {
        ctx.fillStyle = "#38bdf8";
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    const EnemyRegistry = new Map();

    function registerEnemyType(name, config) {
      if (EnemyRegistry.has(name)) {
        throw new Error(`Enemy type '${name}' already exists.`);
      }
      EnemyRegistry.set(name, config);
    }

    class Enemy extends Entity {
      constructor(typeName, position, overrides = {}) {
        const definition = EnemyRegistry.get(typeName);
        if (!definition) {
          throw new Error(`Unknown enemy type: ${typeName}`);
        }
        super(position, definition.radius ?? 16, { ...definition.defaults, ...overrides });
        this.type = typeName;
        this.behaviour = definition.behaviour;
        this.color = definition.color ?? "#f97316";
        this.state = definition.initialState ? definition.initialState() : {};
      }

      update(dt, context) {
        if (this.behaviour?.update) {
          this.behaviour.update(this, dt, context);
        }
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        if (ctx.debug && this.behaviour?.debug) {
          this.behaviour.debug(this, ctx);
        }
      }
    }

    const BonusRegistry = new Map();

    function registerBonusType(name, definition) {
      if (BonusRegistry.has(name)) {
        throw new Error(`Bonus type '${name}' already exists.`);
      }
      BonusRegistry.set(name, definition);
    }

    class Bonus extends Entity {
      constructor(typeName, position, overrides = {}) {
        const definition = BonusRegistry.get(typeName);
        if (!definition) {
          throw new Error(`Unknown bonus type: ${typeName}`);
        }
        super(position, definition.radius ?? 14, { ...definition.defaults, ...overrides });
        this.type = typeName;
        this.definition = definition;
        this.color = definition.color ?? "#22d3ee";
        this.effects = definition.effects ?? {};
        this.life = definition.life ?? Infinity;
      }

      update(dt, context) {
        this.life -= dt;
        if (this.life <= 0) {
          this.dead = true;
        }
        if (this.definition.update) {
          this.definition.update(this, dt, context);
        }
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.rect(this.position.x - this.radius, this.position.y - this.radius, this.radius * 2, this.radius * 2);
        ctx.fill();
      }
    }

    registerEnemyType("patroller", {
      color: "#f97316",
      defaults: {
        speed: 90,
        path: [
          new Vector2(200, 200),
          new Vector2(600, 200),
          new Vector2(600, 400),
          new Vector2(200, 400)
        ]
      },
      initialState() {
        return { target: 0 };
      },
      behaviour: {
        update(enemy, dt) {
          const path = enemy.options.path;
          if (!path?.length) return;
          const target = path[enemy.state.target % path.length];
          const dir = Vector2.from(target).subtract(enemy.position).normalize();
          enemy.position.add(dir.scale(enemy.options.speed * dt));
          if (enemy.position.copy().subtract(target).length() < 8) {
            enemy.state.target = (enemy.state.target + 1) % path.length;
          }
        },
        debug(enemy, ctx) {
          const { path } = enemy.options;
          if (!path) return;
          ctx.save();
          ctx.strokeStyle = "rgba(251, 191, 36, 0.4)";
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
      }
    });

    registerEnemyType("sweeper", {
      color: "#f87171",
      defaults: {
        speed: 130,
        sweepRadius: 180,
        cooldown: 2.4
      },
      initialState() {
        return { cooldown: 0 };
      },
      behaviour: {
        update(enemy, dt, { player }) {
          const toPlayer = player.position.copy().subtract(enemy.position);
          const distance = toPlayer.length();
          enemy.state.cooldown = Math.max(0, enemy.state.cooldown - dt);

          if (distance < enemy.options.sweepRadius) {
            toPlayer.normalize();
            enemy.position.add(toPlayer.scale(enemy.options.speed * dt * 1.1));
            if (distance < player.radius + enemy.radius + 4 && enemy.state.cooldown <= 0) {
              player.hit?.();
              enemy.state.cooldown = enemy.options.cooldown;
            }
          }
        }
      }
    });

    registerBonusType("stamina", {
      color: "#22d3ee",
      defaults: {
        rotationSpeed: 0.8
      },
      effects: {
        stamina: {
          maxMult: 1.6,
          regenMult: 2,
          drainMult: 0.5,
          duration: 12
        }
      },
      update(bonus, dt) {
        bonus.options.angle = (bonus.options.angle ?? 0) + bonus.options.rotationSpeed * dt;
      },
      draw(ctx, bonus) {
        const angle = bonus.options.angle ?? 0;
        ctx.save();
        ctx.translate(bonus.position.x, bonus.position.y);
        ctx.rotate(angle);
        ctx.fillStyle = "#22d3ee";
        ctx.beginPath();
        ctx.moveTo(-bonus.radius, -bonus.radius);
        ctx.lineTo(bonus.radius, 0);
        ctx.lineTo(-bonus.radius, bonus.radius);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    });

    registerBonusType("slowfield", {
      color: "#a855f7",
      defaults: {
        radius: 26
      },
      effects: {
        field: {
          slowFactor: 0.6,
          radius: 120,
          duration: 8
        }
      },
      update(bonus, dt) {
        bonus.options.pulse = (bonus.options.pulse ?? 0) + dt;
      },
      draw(ctx, bonus) {
        ctx.save();
        ctx.globalAlpha = 0.5 + Math.sin((bonus.options.pulse ?? 0) * 4) * 0.25;
        ctx.fillStyle = "#a855f7";
        ctx.beginPath();
        ctx.arc(bonus.position.x, bonus.position.y, bonus.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    });

    class BonusManager {
      constructor() {
        this.active = [];
        this.pool = [];
      }

      spawn(type, position, overrides) {
        const bonus = new Bonus(type, position, overrides);
        this.pool.push(bonus);
        return bonus;
      }

      update(dt, context) {
        for (const bonus of this.pool) {
          if (bonus.dead) continue;
          bonus.update(dt, context);
        }
        this.active = this.pool.filter(b => !b.dead);
      }

      draw(ctx) {
        for (const bonus of this.active) {
          if (bonus.dead) continue;
          if (bonus.definition.draw) {
            bonus.definition.draw(ctx, bonus);
          } else {
            bonus.draw(ctx);
          }
        }
      }
    }

    const LevelLibrary = [
      {
        name: "Training Grounds",
        time: 90,
        chips: 4,
        world: { width: 960, height: 600 },
        playerStart: { x: 120, y: 300 },
        enemies: [
          { type: "patroller", position: { x: 220, y: 220 } },
          { type: "patroller", position: { x: 740, y: 380 }, overrides: { speed: 120 } },
          { type: "sweeper", position: { x: 520, y: 300 } }
        ],
        bonuses: [
          { type: "stamina", position: { x: 420, y: 300 } },
          { type: "slowfield", position: { x: 760, y: 140 } }
        ]
      }
    ];

    class GameState {
      constructor({ canvas, levelIndex = 0 }) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.ctx.debug = false;
        this.levelIndex = levelIndex;
        this.level = null;
        this.player = null;
        this.enemies = [];
        this.bonusManager = new BonusManager();
        this.input = { up: false, down: false, left: false, right: false };
        this.timeRemaining = 0;
        this.chipsDelivered = 0;
        this.totalChips = 0;
        this.lives = 3;
      }

      loadLevel(index = 0) {
        this.levelIndex = index % LevelLibrary.length;
        this.level = LevelLibrary[this.levelIndex];
        if (!this.level) throw new Error(`Level ${index} missing.`);

        this.canvas.width = this.level.world.width;
        this.canvas.height = this.level.world.height;
        this.player = new Player(this.level.playerStart);
        this.player.hit = () => {
          this.lives = Math.max(0, this.lives - 1);
          updateHudLives(this.lives);
        };

        this.enemies = this.level.enemies.map(cfg => new Enemy(cfg.type, cfg.position, cfg.overrides));
        this.bonusManager = new BonusManager();
        for (const bonus of this.level.bonuses ?? []) {
          this.bonusManager.spawn(bonus.type, bonus.position, bonus.overrides);
        }
        this.timeRemaining = this.level.time;
        this.chipsDelivered = 0;
        this.totalChips = this.level.chips;

        updateHudLevel(this.levelIndex + 1);
        updateHudTime(this.timeRemaining);
        updateHudChips(this.chipsDelivered, this.totalChips);
        updateHudBonus("None");
      }

      update(dt) {
        this.timeRemaining = Math.max(0, this.timeRemaining - dt);
        updateHudTime(this.timeRemaining);

        this.player.update(dt, this.input, this.level.world);

        const context = { player: this.player, level: this.level };
        for (const enemy of this.enemies) {
          enemy.update(dt, context);
          if (enemy.position.copy().subtract(this.player.position).length() < enemy.radius + this.player.radius) {
            this.player.hit();
          }
        }

        this.bonusManager.update(dt, context);

        for (const bonus of this.bonusManager.active) {
          const distance = bonus.position.copy().subtract(this.player.position).length();
          if (distance < bonus.radius + this.player.radius) {
            this.player.applyBonus(bonus);
            updateHudBonus(bonus.type);
            bonus.dead = true;
          }
        }
        this.bonusManager.active = this.bonusManager.active.filter(b => !b.dead);
      }

      draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.player.draw(ctx);
        for (const enemy of this.enemies) {
          enemy.draw(ctx);
        }
        this.bonusManager.draw(ctx);
      }
    }

    const hudLevel = document.getElementById("hudLevel");
    const hudLives = document.getElementById("hudLives");
    const hudTime = document.getElementById("hudTime");
    const hudChips = document.getElementById("hudChips");
    const hudBonus = document.getElementById("hudBonus");

    const updateHudLevel = level => (hudLevel.textContent = level);
    const updateHudLives = lives => (hudLives.textContent = lives);
    const updateHudTime = seconds => {
      const m = Math.floor(seconds / 60).toString().padStart(2, "0");
      const s = Math.floor(seconds % 60).toString().padStart(2, "0");
      hudTime.textContent = `${m}:${s}`;
    };
    const updateHudChips = (delivered, total) => (hudChips.textContent = `${delivered}/${total}`);
    const updateHudBonus = label => (hudBonus.textContent = label);

    const canvas = document.getElementById("gameCanvas");
    const game = new GameState({ canvas });
    game.loadLevel(0);

    const keys = new Map([
      ["ArrowUp", "up"],
      ["KeyW", "up"],
      ["ArrowDown", "down"],
      ["KeyS", "down"],
      ["ArrowLeft", "left"],
      ["KeyA", "left"],
      ["ArrowRight", "right"],
      ["KeyD", "right"]
    ]);

    const keyHandler = (state) => (event) => {
      const mapping = keys.get(event.code);
      if (mapping) {
        event.preventDefault();
        game.input[mapping] = state;
      }
      if (event.code === "KeyD") {
        game.ctx.debug = state;
      }
    };

    window.addEventListener("keydown", keyHandler(true));
    window.addEventListener("keyup", keyHandler(false));

    const toggleDebugBtn = document.getElementById("toggleDebug");
    toggleDebugBtn.addEventListener("click", () => {
      game.ctx.debug = !game.ctx.debug;
    });

    document.getElementById("restartLevel").addEventListener("click", () => {
      game.loadLevel(game.levelIndex);
    });
    document.getElementById("restartGame").addEventListener("click", () => {
      game.loadLevel(0);
      game.lives = 3;
      updateHudLives(game.lives);
    });

    const modal = document.getElementById("modal");
    const modalClose = document.getElementById("modalClose");
    modalClose.addEventListener("click", () => modal.close());

    const modalQueue = [];
    function showModal({ title, body }) {
      modal.querySelector("#modalTitle").textContent = title;
      modal.querySelector("#modalBody").textContent = body;
      modal.showModal();
    }

    let last = performance.now();
    function loop(timestamp) {
      const dt = Math.min(0.1, (timestamp - last) / 1000);
      last = timestamp;

      game.update(dt);
      game.draw();

      if (modalQueue.length && !modal.open) {
        showModal(modalQueue.shift());
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    window.registerEnemyType = registerEnemyType;
    window.registerBonusType = registerBonusType;
    window.game = game;
  </script>
</body>
</html>
